{"data":{"type":"contents","id":"data-down-actions-up","attributes":{"html":"<p>I hear many people asking how they can compose components, and since the Ember\nGuides [http://guides.emberjs.com/]  don't help us in that respect, I wrote my\nown guide as a PR [https://github.com/emberjs/guides/pull/66]  to the guides. I\nfigured that I might as well get this out to the public while I wait on it\ngetting merged. This will allow us to improve the guide, so feel free to leave\ncomments/suggestions in the PR (inline, etc).</p>\n<hr />\n<p>Components really shine when you use them to their full potential, which is when\nyou compose them.\nTake for example the <ul>  element, and the fact that only <li>  elements are\nappropriate as children.\nIf we want the same type of behavior, then we have to compose our components.</p>\n<p>Just like we compose regular HTML elements, we can do the same with components.</p>\n<p>{{#user-list users=model sortBy='name' as |user|}}\n  {{user-card user=user}}\n{{/user-list}}</p>\n<p>Component Blocks\nComponents can be used in two forms, just like regular HTML elements.</p>\n<p>Inline Form</p>\n<p>{{user-list users=model}}</p>\n<p>Block Form</p>\n<p>{{#user-list users=model}}\n  {{!-- custom template here --}}\n{{/user-list}}</p>\n<p>To compose components, we must use the block form, but we must also\nbe able to distinguish from within our component which form the user\nis implementing. This can be done with the template  property.</p>\n<p>{{#if template}}\n  {{yield}}\n{{else}}\n  </p>\n<p>No Template Specified</p>\n<p>{{/if}}</p>\n<p>We can check if template  is truthy, and if it is that means that the user\nspecified a custom template.\nWell, once we have a template, we probably want to use that in our component,\nand that's exactly what {{yield}}  does.</p>\n<p>This helper can be used once, or many times. You can make your component into a\ntype of <ul>  element,\nthat is a list that will repeat n times. Like the following example, where we\ncan output a custom summary.</p>\n<p>{{#each posts as |post|}}\n  </p>\n<h3>{{post.title}}</h3>\n<p>{{yield}}</p>\n<p>{{/each}}</p>\n<p>Which can be used like so:</p>\n<p>{{#post-list posts=model}}\n  Greatest post ever!\n{{/post-list}}</p>\n<p>And will result in the following HTML:</p>\n<div id=\"ember123\" class=\"ember-view\">\n  <h3>Tomster goes to town</h3>\n  <p>Greatest post ever!</p>\n  <h3>Tomster on vacation</h3>\n  <p>Greatest post ever!</p>\n</div>\n<p>But what use is it to just output the same thing over and over? Don't we want to\ncustomize our posts,\nand display the right content? Sure we do. Lets explore the {{yield}}  helper a\nbit.</p>\n<p>Data Down\nTo accomplish composability beyond just simple templates, we need to pass\ncontext to those templates. This can be done with the {{yield}}  helper.</p>\n<p>The {{yield}}  defines where the template we defined inside our component block\nwill yield in the component's layout, as we saw in the previous section. Apart\nfrom that, the yield helper also allows us to send data down, providing a\ncontext for the templates.</p>\n<p>{{yield}}\n{{yield \"hello\"}}\n{{yield item}}\n{{yield this \"bye\"}}</p>\n<p>By default yield does not send any context, but you can provide an arbitrary\nnumber of arguments.\nOnce you are sending data down, the child components need to consume that data.\nWe can do this with the as  operator. Let's take {{yield user \"My Item\"}}  as an\nexample:</p>\n<p>{{#user-list users=model as |user title|}}\n  </p>\n<h3>{{title}}</h3>\n<p>{{user-card user=user}}\n{{/user-list}}</p>\n<p>Now {{user-card}}  has access to the current user, which would change if \n{{user-list}}  placed it's yield helper inside an each block.\nThis opens up the possibility to use the {{component}}  helper for different\ntemplates, for example:</p>\n<h3>Profile</h3>\n<p>{{yield \"user-avatar\" user}}\n{{yield \"user-contact\" user}}</p>\n<p>{{#user-profile user=model as |section user|}}\n  {{component section user=user}}\n{{/user-profile}}</p>\n<p>With the {{component}}  helper, we can bind our context to names of components\ndynamically, which in this case means that we can customize\nthe user profile with custom components bound to the relevant data. This means\nwe can have multiple extension points in our components, making them much more\nversatile.</p>\n<p>Actions Up\nNow that we can send data down, we probably want to manipulate that data via\nsome user interaction,\nlike changing a user's avatar, or whatever it is you're doing. We can accomplish\nthis by using actions.</p>\n<p>Actions are great, but for actions to work in the right context, we must use the\n targetObject  property to specify\nwhere we want the action to go. Before we can specify the targetObject  property\non our \"acting\" component, we need\nto expose that target as the context.</p>\n<p>{{yield this}}</p>\n<p>The targetObject  is the component that you want to handle the action, in this\ncase it's the parent component.</p>\n<p>{{#user-profile user=model as |profile|}}\n  {{user-avatar change=\"updateAvatar\" targetObject=profile}}\n{{/user-profile}}</p>\n<p>Since profile  is the instance of the {{user-profile}}  component, that means it\ncan accept the \"updateAvatar\" action request.\nThe action must be defined on the user profile component instance.</p>\n<p>Here's a mash-up of the possible scenarios with actions:</p>\n<p>{{#full-post post=model as |fullPost|}}\n  {{post-like like=\"like\" targetObject=fullPost}}\n  {{post-subscribe subscribe=\"subscribe\" targetObject=fullPost}}\n  {{comment-box submit=\"addComment\" targetObject=post viewName=\"commentBox\"}}</p>\n<p><button type=\"button\" {{action \"fullScreen\" target=commentBox}}>Zen Mode</button>\n{{/full-post}}</p>\n<p>Note: When using {{action}}  helpers, instead of a component, you need to\nspecify target  instead of targetObject.\nAlso, when working with actions and sibling components, use viewName  to\n\"export\" the sibling component instance as a possible target.</p>","content":"I hear many people asking how they can compose components, and since the Ember\nGuides [http://guides.emberjs.com/]  don't help us in that respect, I wrote my\nown guide as a PR [https://github.com/emberjs/guides/pull/66]  to the guides. I\nfigured that I might as well get this out to the public while I wait on it\ngetting merged. This will allow us to improve the guide, so feel free to leave\ncomments/suggestions in the PR (inline, etc).\n\n\n--------------------------------------------------------------------------------\n\nComponents really shine when you use them to their full potential, which is when\nyou compose them.\nTake for example the <ul>  element, and the fact that only <li>  elements are\nappropriate as children.\nIf we want the same type of behavior, then we have to compose our components.\n\nJust like we compose regular HTML elements, we can do the same with components.\n\n{{#user-list users=model sortBy='name' as |user|}}\n  {{user-card user=user}}\n{{/user-list}}\n\n\nComponent Blocks\nComponents can be used in two forms, just like regular HTML elements.\n\nInline Form\n\n{{user-list users=model}}\n\n\nBlock Form\n\n{{#user-list users=model}}\n  {{!-- custom template here --}}\n{{/user-list}}\n\n\nTo compose components, we must use the block form, but we must also\nbe able to distinguish from within our component which form the user\nis implementing. This can be done with the template  property.\n\n{{#if template}}\n  {{yield}}\n{{else}}\n  <p>No Template Specified</p>\n{{/if}}\n\n\nWe can check if template  is truthy, and if it is that means that the user\nspecified a custom template.\nWell, once we have a template, we probably want to use that in our component,\nand that's exactly what {{yield}}  does.\n\nThis helper can be used once, or many times. You can make your component into a\ntype of <ul>  element,\nthat is a list that will repeat n times. Like the following example, where we\ncan output a custom summary.\n\n{{#each posts as |post|}}\n  <h3>{{post.title}}</h3>\n  <p>{{yield}}</p>\n{{/each}}\n\n\nWhich can be used like so:\n\n{{#post-list posts=model}}\n  Greatest post ever!\n{{/post-list}}\n\n\nAnd will result in the following HTML:\n\n<div id=\"ember123\" class=\"ember-view\">\n  <h3>Tomster goes to town</h3>\n  <p>Greatest post ever!</p>\n  <h3>Tomster on vacation</h3>\n  <p>Greatest post ever!</p>\n</div>\n\n\nBut what use is it to just output the same thing over and over? Don't we want to\ncustomize our posts,\nand display the right content? Sure we do. Lets explore the {{yield}}  helper a\nbit.\n\nData Down\nTo accomplish composability beyond just simple templates, we need to pass\ncontext to those templates. This can be done with the {{yield}}  helper.\n\nThe {{yield}}  defines where the template we defined inside our component block\nwill yield in the component's layout, as we saw in the previous section. Apart\nfrom that, the yield helper also allows us to send data down, providing a\ncontext for the templates.\n\n{{yield}}\n{{yield \"hello\"}}\n{{yield item}}\n{{yield this \"bye\"}}\n\n\nBy default yield does not send any context, but you can provide an arbitrary\nnumber of arguments.\nOnce you are sending data down, the child components need to consume that data.\nWe can do this with the as  operator. Let's take {{yield user \"My Item\"}}  as an\nexample:\n\n{{#user-list users=model as |user title|}}\n  <h3>{{title}}</h3>\n  {{user-card user=user}}\n{{/user-list}}\n\n\nNow {{user-card}}  has access to the current user, which would change if \n{{user-list}}  placed it's yield helper inside an each block.\nThis opens up the possibility to use the {{component}}  helper for different\ntemplates, for example:\n\n<h3>Profile</h3>\n{{yield \"user-avatar\" user}}\n{{yield \"user-contact\" user}}\n\n\n{{#user-profile user=model as |section user|}}\n  {{component section user=user}}\n{{/user-profile}}\n\n\nWith the {{component}}  helper, we can bind our context to names of components\ndynamically, which in this case means that we can customize\nthe user profile with custom components bound to the relevant data. This means\nwe can have multiple extension points in our components, making them much more\nversatile.\n\nActions Up\nNow that we can send data down, we probably want to manipulate that data via\nsome user interaction,\nlike changing a user's avatar, or whatever it is you're doing. We can accomplish\nthis by using actions.\n\nActions are great, but for actions to work in the right context, we must use the\n targetObject  property to specify\nwhere we want the action to go. Before we can specify the targetObject  property\non our \"acting\" component, we need\nto expose that target as the context.\n\n{{yield this}}\n\n\nThe targetObject  is the component that you want to handle the action, in this\ncase it's the parent component.\n\n{{#user-profile user=model as |profile|}}\n  {{user-avatar change=\"updateAvatar\" targetObject=profile}}\n{{/user-profile}}\n\n\nSince profile  is the instance of the {{user-profile}}  component, that means it\ncan accept the \"updateAvatar\" action request.\nThe action must be defined on the user profile component instance.\n\nHere's a mash-up of the possible scenarios with actions:\n\n{{#full-post post=model as |fullPost|}}\n  {{post-like like=\"like\" targetObject=fullPost}}\n  {{post-subscribe subscribe=\"subscribe\" targetObject=fullPost}}\n  {{comment-box submit=\"addComment\" targetObject=post viewName=\"commentBox\"}}\n\n  <button type=\"button\" {{action \"fullScreen\" target=commentBox}}>Zen Mode</button>\n{{/full-post}}\n\n\nNote: When using {{action}}  helpers, instead of a component, you need to\nspecify target  instead of targetObject.\nAlso, when working with actions and sibling components, use viewName  to\n\"export\" the sibling component instance as a possible target.","title":"Data Down, Actions Up","date":"2015-04-20T16:34:16.000Z"},"relationships":{"authors":{"data":[{"type":"authors","id":"ilya"}]},"tags":{"data":[{"type":"tags","id":"ember-js"},{"type":"tags","id":"components"}]}}}}